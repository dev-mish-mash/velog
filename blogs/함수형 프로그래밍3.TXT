> _본 글은 2018년 GOTO conference에서 Russ Olsen이 발표한 'Functional Programming in 40 Minutes' 의 강연 내용을 제가 이해한 내용을 바탕으로 재구성한 것입니다._


> ### 읽으면 좋은 분들
2년 경력 미만의 프로그래머 분들
객체지향 프로그래밍에 익숙한 분들 - _대부분의 강연 내용이 객체지향 프로그래밍을 예로 들면서 비교하며 진행됩니다._
함수형 프로그래밍에 대한 지식이 없는 분들
함수형 프로그래밍을 실용적인 관점에서 간략하게 이해하고 싶은 분들


## 함수형 프로그래밍의 구성 요소
저번 포스팅에서, **객체 지향 자체가 기존 기능의 변화나 혹은 새로운 기능의 추가에 유연성 있는 유지 보수가 어렵다**는 결론을 내린 바 있습니다. 물론 뛰어난 프로그래머라면 이 문제를 객체지향형을 유지하면서도 슬기롭게 해결 할 수 있겠지만, 좀 더 근본적으로 이 문제를 해결할 수는 없을까요? 

이번 포스팅에서는 이 문제를 해결하기 위해, 객체지향형을 대체할 함수형 프로그래밍의 기본 구성 요소를 알아보겠습니다.

### 순수 함수(pure function)

당연하게도, 함수형 프로그래밍은 이름 자체로 함수를 사용합니다. 하지만 그냥 함수를 사용하는 것이 아닌, **순수 함수(pure function)를 사용**한다는 점에서 차이가 있습니다. 

순수 함수는 수학적인 정의의 함수와 비슷합니다. 입력(input) 가지고 연산하여 출력시킵니다(output). 
여기서 중요한 점은 다음과 같습니다.
<ol> 
  <li> 같은 입력에 대해 항상 똑같이 출력함</li>
  <li> 외부에 영향을 주거나 받지 않음</li>
</ol>

#### 순수함수 예시(x2) - javascript
```
const double = x => 2 * x;
```
이 함수는 주어진 입력에 2를 곱하여 출력하는 함수입니다. 모두가 알다시피, 이 함수는 언제 실행하든 항상 입력의 2배 값만을 반환합니다. 날씨가 맑던, 비가 오던 혹은 눈이 오던, 오후 6시에 실행하든 아침에 실행하든 출력에는 영향을 주지 않고 항상 똑같죠.

#### 순수함수가 아닌 함수 예시(Date 생성, 외부에 영향) - javascript
```
const createDate = (param) => {
    return new Date();
}
```
이 함수는 현재 시각을 반환하는 함수입니다. 입력값 param에 숫자 1을 집어넣었을 때 항상 똑같은 값이 반환되지 않고, 그때 그때 다르기 때문에 순수 함수가 아닙니다. 
```
const modifyA = (param) => {
    a = 'something'
}
```
이 함수 또한, 함수 내부에 있는 것이 아닌 어디서 가져왔을지 모를 변수 a를 바꾸고 있습니다. 외부에 영향을 주고 있으므로 순수 함수가 아닙니다.

```
const modifyInputParams = (param) => {
    param.newProperty = 'something'
}
```

이 함수는 입력값으로 받은 param을 직접 수정하고 있습니다. 입력값 자체가 함수 외부에서 선언되었을 것이므로, 이 경우에도 외부에 영향을 주고 있으니 순수 함수가 아닙니다.

#### 사이드 이펙트(side effect)
이때, **함수를 순수하지 않게 만드는 부수적인 효과들을 사이드 이펙트(side effect)** 라고 합니다.

그럼, **순수 함수라는 것은 사이드 이펙트가 없는 함수**라고 말할 수도 있겠습니다.

### 순수 함수가 왜 중요한가?
이제 순수 함수가 뭔지는 알겠는데, 이게 왜 중요할까요? 그냥 그렇구나 수준이지, 눈이 번쩍 뜨일 정도는 아닌데요. 

그래서 구체적인 예시를 들어 보겠습니다. 

다음과 같이 배열인 input값 x와, 순수 함수 a로 계산된 결과값인 y가 있습니다. 그럼 이때 x는 무엇일까요? 

![](https://images.velog.io/images/dev-mish-mash/post/cc12ccf7-17ae-4322-a4f9-31c8da6b587f/image.png)

```a```가 순수 함수이므로 ```x```는 원래 그대로 ```['a','b','c']``` 가 될 것입니다.

그 후에 ```b``` 함수에 ```x```를 집어넣어서 ```z```라는 결과값을 얻어냈다고 해 보죠.
이때 우리는 ```x```가 항상 변하지 않고 ```['a','b','c']``` 인 것을 알기 때문에, ```y=a(x)``` 에서 무슨 일이 일어나든 ```z```의 값은 항상 일정할 것입니다.

따라서 **```z``` 함수에서 버그가 나게 되면, 우리는 ```y=a(x)``` 부분의 코드를 볼 필요 없이 ```y=b(x)``` 에서만 디버그를 진행하면 됩니다.**

음... 뭔가 중요한 것 같은데, 그래도 별로 와닿진 않습니다. 그래봐야 함수 하나 안 보면 되는 정도 아닐까요?
그럼 이러면 어떨까요?
![](https://images.velog.io/images/dev-mish-mash/post/7b1ed802-d151-4335-a89f-48080f69a1d4/image.png)


a 함수가 미친듯이 복잡하게 변하고 순수 함수가 아니라고 해보죠. 이때 만약 ```z``` 함수에서 버그가 나면 어떨까요?

우리는 그 원인이 ```a``` 함수에서 ```x```를 건드려서 나는 것이 아니길 간절히 바래야합니다. 아니면 1만줄짜리 코드일 수도 있는 ```a``` 함수를 까서 그 중간에 ```x```가 바뀌는 원인을 찾아야할지도 모를 일이고, 그것만으로도 부족할수도 있습니다.

이 예제에서 알 수 있는 중요한 점은, **순수 함수로만 로직을 짜면 쓸데없는 디펜던시를 최소화 할 수 있고, 함수 하나당 유닛 테스트(unit test)가 가능해지기 때문에 코드의 디버깅 난이도를 굉장히 쉽게 만들어준다는 것입니다.**




### 불변성 자료 구조

### 사이드 이펙트 브릿지



